<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Ahsan Muzammil</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">Maze Solver and Verification</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="generic.html" class="active">Project Overview</a></li>
						<li><a href="https://github.com/AhsanM71/Maze-Solver-and-Verification-System">GitHub Repository</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">Project Details</h1>
							<span class="image fit"><img src="images/Rv_Qav.gif" alt="" /></span>
							<h2>Introduction</h2>
							<p>
								I developed a maze-solving algorithm to solve a text-based maze written using special characters like <code>#</code>, which represent walls, 
								and white spaces, which represent potential paths. The project includes two key algorithms:
							</p>
						
							<h2>Right Hand Rule</h2>
							<p>
								The right-hand rule algorithm involves following the right wall of the maze to find an exit. 
								The player keeps its right hand (or side) touching a wall, continuously moving forward 
								and turning right when possible. This simple rule is effective for solving mazes that have connected walls 
								and are not completely isolated.
							</p>
						
							<h2>Breadth-First Search (BFS)</h2>
							<p>
								The BFS algorithm explores all possible paths level by level, starting from the starting point and expanding 
								to neighboring cells. It uses a queue data structure to explore all available paths systematically, ensuring 
								that it finds the shortest path to the exit. BFS is a guaranteed method for finding the shortest route in 
								a maze, making it more efficient for more complex mazes.
							</p>
							<h2>More Features:</h2>
							<p>
								Another feature of the project allows users to input a possible solution to the maze. The program then verifies 
								if the solution is correct by checking the path against the maze's layout. 
							</p>
						
							<p>
								Additionally, I implemented a benchmark mode that allows users to compare the performance of the two algorithms. 
								The benchmark measures the number of moves required to solve the maze and the execution time for each algorithm.
							</p>
						
							<h2>User Interface</h2>
							<p>
								The user interacts with the project via the command line interface. They can choose from three specific flags:
								<ul>
									<li>Request a solution for the maze</li>
									<li>Verify a user-provided solution</li>
									<li>Run a benchmark to compare algorithms</li>
								</ul>
								After choosing the desired operation, the user provides the path to the maze file and executes the Java code to get the respective output.
							</p>
							<h2>Project Toolkit</h2>
							<ul>
								<li><strong>Java</strong>: The main programming language used to develop the maze-solving algorithms and handle user inputs and outputs through the command line.</li>
								<li><strong>JUnit</strong>: Used to write unit tests for verifying the functionality of each method and class in the project. It ensures correctness and prevents future bugs.</li>
								<li><strong>SOLID Principles</strong>: These principles were applied to maintain clean, modular, and maintainable code. For instance, the "Single Responsibility Principle" ensured each class had a distinct purpose.</li>
								<li><strong>GRASP Principles</strong>: These design principles helped guide decisions on object responsibility and interactions. The "Controller" pattern was used to handle user inputs efficiently.</li>
								<li><strong>GoF Patterns</strong>: The project applied the "Strategy" pattern to switch between the BFS and right-hand rule algorithms dynamically, enhancing flexibility in choosing maze-solving strategies.</li>
								<li><strong>SonarQube</strong>: Used for static code analysis to ensure code quality and detect potential issues such as code smells, duplications, or bugs. It helped maintain high coding standards throughout the project.</li>
								<li><strong>Encapsulation</strong>: Applied to hide the internal logic of classes, exposing only the necessary methods. This made the code more secure and modular, allowing changes without breaking dependencies.</li>
								<li><strong>Performance Benchmarking</strong>: Implemented to measure and compare the efficiency of the right-hand rule and BFS algorithms based on execution time and the number of moves, helping optimize the solution process.</li>
							</ul>
							<section>
								<h2>Source Code</h2>
								<a href="https://github.com/AhsanM71/Maze-Solver-and-Verification-System" class="button">GitHub Repository</a>
							</section>
						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<p style="text-align: center;">
							<li>Copyright &copy; 2024 Ahsan Muzammil. All rights reserved.</li>
						</p>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>